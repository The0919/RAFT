#!/usr/bin/env python3

import argparse, socket, time, json, select, struct, sys, math, os
from enum import Enum

BROADCAST = "FFFF"
UNKNOWN_ID = 'FFFF'
HEARTBEAT_INTERVAL = .2
ELECTION_TIMEOUT = HEARTBEAT_INTERVAL * 2

# LOOK AT THIS POST, CURRENT ISSUE WITH RECEIVEING MESSAGES WHEN THERE IS NO LEADER,
# GETS BORADCAST TO EVERYONE OVER AND OVER
# https://piazza.com/class/l7kwgqgh3pd6vc/post/728
class MessageType(Enum):
  HELLO = 'hello'
  GET = 'get'
  PUT = 'put'
  REDIRECT = 'redirect'
  APPEND = 'append'
  APPEND_ACK = 'ack'
  OK = 'ok'
  REQUEST_VOTE = 'vote'
  REQUEST_VOTE_ACK = 'vote ack'

class State(Enum):
  LEADER = 'leader'
  FOLLOWER = 'follower'
  CANDIDATE = 'candidate'

class LogEntry:
  def __init__(self, term_id: int, key: str, value: str):
    self.term_id = term_id
    self.key = key
    self.value = value

  def to_dict(self):
    return {
      'term': self.term_id,
      'key': self.key,
      'value': self.value
    }

  def __str__(self):
    return str(self.to_dict())

  @staticmethod
  def from_dict(d: dict):
    return LogEntry(d['term'], d['key'], d['value'])

  def __eq__(self, other):
    return (
        self.term_id == other.term_id
        and self.key == other.key
        and self.value == other.value
    )


def parse_msg(s: str):
  parsed = json.loads(s)
  parsed['type'] = MessageType(parsed['type'])
  return parsed


class Replica:
  def __init__(self, port, id, others):
    self.assumed_leader = UNKNOWN_ID
    self.state = State.FOLLOWER
    self.term_number = 0
    self.port = port
    self.id = id
    self.others = others
    self.votes = 0
    self.votedFor = None

    self.log: list[LogEntry] = []
    self.commit_index = -1
    self.values = {}
    self.follower_confirmed_indices = dict.fromkeys(others, -1)

    self.request_queue = []

    self.socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    self.socket.bind(('localhost', 0))

    print("Replica %s starting up" % self.id, flush=True)
    self.send({}, BROADCAST, MessageType.HELLO)
    print("Sent hello message.", flush=True)

    self.MESSAGE_HANDLING = {
      State.LEADER: {
        MessageType.GET: self.handle_get,
        MessageType.PUT: self.handle_put,
        MessageType.APPEND_ACK: self.handle_append_ack,
        MessageType.REQUEST_VOTE: lambda msg: self.update_term(msg['term'])
      }, State.FOLLOWER: {
        MessageType.GET: self.handle_redirect,
        MessageType.PUT: self.handle_redirect,
        MessageType.APPEND: self.handle_append,
        MessageType.REQUEST_VOTE: self.handle_vote_request
      }, State.CANDIDATE: {
        MessageType.GET: self.handle_defer,
        MessageType.PUT: self.handle_defer,
        MessageType.REQUEST_VOTE: self.handle_vote_request,
        MessageType.REQUEST_VOTE_ACK: self.handle_vote_request_ack
      }
    }

  def handle_msg(self, msg: dict):
    msg_type = msg['type']
    if msg_type in self.MESSAGE_HANDLING[self.state]:
      self.MESSAGE_HANDLING[self.state][msg_type](msg)

  def send(self, message: dict, to: str, t: MessageType):
    message.update({
      'type': t.value,
      'src': self.id,
      'dst': to,
      'leader': self.assumed_leader
    })
    self.socket.sendto(json.dumps(message).encode('utf-8'), ('localhost', self.port))

  def run(self):
    timer = time.time()
    while True:
      if self.state == State.LEADER and time.time() - timer > HEARTBEAT_INTERVAL:
        print("HEARTBEAT SENT", flush=True)
        timer = time.time()
        for other in self.others:
          self.send_append(other, [])

      if self.state == State.FOLLOWER and time.time() - timer > ELECTION_TIMEOUT and self.votedFor is None:
        print("NO HEARTBEAT, 'lection time", flush=True)
        timer = time.time()
        self.start_election()
    
      readable, writable, exceptional = select.select([self.socket], [], [], .5)
      if len(readable) > 0:
        data, addr = self.socket.recvfrom(65535)
        msg = data.decode('utf-8')

        print("Received message '%s'" % (msg,), flush=True)
        self.handle_msg(parse_msg(msg))

  def update_term(self, term):
    if self.term_number < term:
      if self.state == State.LEADER or self.state == State.CANDIDATE:
        self.assumed_leader = UNKNOWN_ID
        self.state = State.FOLLOWER
      self.votedFor = None
      self.term_number = term

  def handle_redirect(self, msg):
    self.send({'MID': msg['MID']}, msg['src'], MessageType.REDIRECT)

  def handle_defer(self, msg):
    self.request_queue.append(msg)

  def handle_vote_request_ack(self, msg):
    self.update_term(msg['term'])
    if msg['voteGranted']:
      self.votes += 1
    if self.votes > len(self.others) // 2:
      print("I WON THE ELECTRON", flush=True)
      self.state = State.LEADER
      self.assumed_leader = self.id
      self.process_queue()
      for other in self.others:
        self.send_append(other, [])

  def start_election(self):
    self.votes = 1
    self.term_number += 1
    self.votedFor = self.id
    self.assumed_leader = UNKNOWN_ID
    self.state = State.CANDIDATE
    last_term = self.term_number if len(self.log) == 0 else self.log[-1].term_id
    self.send({
      'term':self.term_number,
      'candidateId':self.id,
      'lastLogIndex': len(self.log)-1,
      'lastLogTerm': last_term
      }, BROADCAST, MessageType.REQUEST_VOTE)

  def handle_vote_request(self, msg: dict):
    print("GOT VOTE REQUEST", flush=True)
    candidate_id, candidate_log_index, candidate_term =\
        msg['candidateId'], msg['lastLogIndex'], msg['term']
    self.update_term(candidate_term)
    grant_vote = (
        (self.votedFor is None or self.votedFor == candidate_id)
        and candidate_term >= self.term_number
        and candidate_log_index >= len(self.log)-1)
    if grant_vote:
      print("VOTED FOR", candidate_id, self.term_number, flush=True)
      self.votedFor = candidate_id
    self.send({
      'term': self.term_number,
      'voteGranted': grant_vote
      }, candidate_id, MessageType.REQUEST_VOTE_ACK)

  def process_queue(self):
    while len(self.request_queue) > 0:
      self.handle_msg(self.request_queue.pop())

  def handle_get(self, msg: dict):
    key = msg['key']
    value = self.values[key] if key in self.values else ''
    self.send({'value': value, 'MID': msg['MID']}, msg['src'], MessageType.OK)

  def handle_put(self, msg: dict):
    key, value = msg['key'], msg['value']
    # add the message to the log
    self.log.append(LogEntry(self.term_number, key, value))
    # send append RPCs
    for follower in self.others:
      self.send_append(follower, putter=msg['src'], mid=msg['MID'])

  def handle_append_ack(self, msg: dict):
    follower, term, success = msg['src'], msg['term'], msg['success']
    self.update_term(term)
    if success:
      confirmed_index = msg['confirmed_index']
      # update confirmed index for follower
      self.follower_confirmed_indices[follower] = confirmed_index
      # update commit index if a majority of followers have confirmed up to at least
      confirmed_at_least = lambda f: self.follower_confirmed_indices[f] >= confirmed_index
      if len(list(filter(confirmed_at_least, self.others))) > len(self.others) // 2:
        self.commit_to(confirmed_index)
        if 'MID' in msg:
          self.send({'MID': msg['MID']}, msg['putter'], MessageType.OK)
    else:
      # todo: handle log resync
      None

  def commit_to(self, index):
    to = min(index, len(self.log) - 1)
    for i in range(self.commit_index, to + 1):
      entry = self.log[i]
      self.values[entry.key] = entry.value
    self.commit_index = max(self.commit_index, to)

  def handle_append(self, msg: dict):
    leader_term, prev_log_index, leader_commit, prev_log_term, putter \
      = msg['term'], msg['prev_log_index'], msg['leader_commit'], msg['prev_log_term'], msg['putter']
    entries = list(map(LogEntry.from_dict, msg['entries']))
    if leader_term >= self.term_number:
      self.assumed_leader = msg['src']
      self.term_number = leader_term
      self.state = State.FOLLOWER
    success = (
        leader_term >= self.term_number
        and (prev_log_index == -1 or (prev_log_index < len(self.log)
        and prev_log_term == self.log[prev_log_index].term_id))
    )
    if success and len(msg['entries']) > 0:
      self.update_log(entries, prev_log_index + 1)
    else:
      print('leader_term:', leader_term, flush=True)
      print('prev_log_index', prev_log_index, flush=True)
      print('leader_term >= self.term_number', leader_term >= self.term_number, flush=True)
      if leader_term >= self.term_number:
        print('prev_log_index < len(self.log)', prev_log_index < len(self.log), flush=True)
      if leader_term >= self.term_number and prev_log_index < len(self.log):
        print('(prev_log_index == -1 or prev_log_term == self.log[prev_log_index].term_id)', (prev_log_index == -1 or prev_log_term == self.log[prev_log_index].term_id), flush=True)
    confirmed_index = len(self.log) - 1
    if leader_commit > self.commit_index:
      self.commit_to(leader_commit)
    self.send({
      'term': self.term_number,
      'success': success,
      'confirmed_index': confirmed_index,
      'putter': putter,
      'MID': msg['MID']
    }, msg['src'], MessageType.APPEND_ACK)

  def update_log(self, entries: list, offset: int):
    before = list(self.log)
    for i in range(len(entries)):
      log_index = offset + i
      if not log_index < len(self.log) or self.log[log_index] != entries[i]:
        self.log = self.log[:log_index] + entries[i:]
        break
    print('updated log from', before, 'to', self.log, flush=True)

  def send_append(self, follower: str, entries=None, putter=None, mid=None):
      prev_log_index = self.follower_confirmed_indices[follower]
      # Log is empty/prev_log_index starts as -1, creates index error
      # sets prev_log_term to self term number, probably not right!!
      prev_log_term = self.term_number if prev_log_index < 0 or prev_log_index >= len(self.log)\
          else self.log[prev_log_index].term_id
      if entries is None:
        entries = list(map(lambda entry: entry.to_dict(), self.log[prev_log_index + 1:]))
      response = {
        'term': self.term_number,
        'prev_log_index': prev_log_index,
        'prev_log_term': prev_log_term,
        'entries': entries,
        'leader_commit': self.commit_index
      }
      if putter is not None:
        response.update({
          'putter': putter,
          'MID': mid
        })
      self.send(response, follower, MessageType.APPEND)

if __name__ == "__main__":
  parser = argparse.ArgumentParser(description='run a key-value store')
  parser.add_argument('port', type=int, help="Port number to communicate")
  parser.add_argument('id', type=str, help="ID of this replica")
  parser.add_argument('others', metavar='others', type=str, nargs='+', help="IDs of other replicas")
  args = parser.parse_args()
  replica = Replica(args.port, args.id, args.others)
  replica.run()
