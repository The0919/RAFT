#!/usr/bin/env python3

import argparse, socket, time, json, select, struct, sys, math, os
from enum import Enum

BROADCAST = "FFFF"
UNKNOWN_ID = 'FFFF'

class MessageType(Enum):
  HELLO = 'hello'
  GET = 'get'
  PUT = 'put'
  REDIRECT = 'redirect'
  APPEND = 'append'
  APPEND_ACK = 'ack'
  OK = 'ok'

class LogEntry:
  def __init__(self, term_id: int, key: str, value: str):
    self.term_id = term_id
    self.key = key
    self.value = value

  def to_dict(self):
    return {
      'term': self.term_id,
      'key': self.key,
      'value': self.value
    }

  @staticmethod
  def from_dict(d: dict):
    return LogEntry(d['term'], d['key'], d['value'])

  def __eq__(self, other):
    return (
        self.term_id == other.term_id
        and self.key == other.key
        and self.value == other.value
    )

class Replica:
  def __init__(self, port, id, others):
    self.assumed_leader = UNKNOWN_ID
    self.term_number = 0
    self.port = port
    self.id = id
    self.others = others

    self.log: list[LogEntry] = []
    self.commit_index = -1
    self.values = {}
    self.follower_confirmed_indices = dict.fromkeys(others, -1)

    self.socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    self.socket.bind(('localhost', 0))

    print("Replica %s starting up" % self.id, flush=True)
    self.send({}, BROADCAST, MessageType.HELLO)
    print("Sent hello message.", flush=True)

  def send(self, message: dict, to: str, t: MessageType):
    message.update({
      'type': t,
      'src': self.id,
      'dest': to,
      'leader': self.assumed_leader
    })
    self.socket.sendto(json.dumps(message).encode('utf-8'), ('localhost', self.port))

  def run(self):
    while True:
      readable, writable, exceptional = select.select([self.socket], [], [], .5)
      if len(readable) > 0:
        data, addr = self.socket.recvfrom(65535)
        msg = data.decode('utf-8')

        print("Received message '%s'" % (msg,), flush=True)
        self.handle_msg(json.loads(msg))
      else:
        # timer stuff
        

  def handle_msg(self, msg: dict):
    msg_type = msg['type']
    if self.id == self.assumed_leader:
      if msg_type == MessageType.GET:
        self.handle_get(msg)
      elif msg_type == MessageType.PUT:
        self.handle_put(msg)
      elif msg_type == MessageType.APPEND_ACK:
        self.handle_append_ack(msg)
    else:
      if msg_type in [MessageType.GET, MessageType.PUT]:
        self.send({'MID': msg['MID']}, msg['src'], MessageType.REDIRECT)
      elif msg_type == MessageType.APPEND:
        self.handle_append(msg)

  def handle_get(self, msg: dict):
    key = msg['key']
    value = self.values[key] if key in self.values else ''
    self.send({'value': value, 'MID': msg['MID']}, msg['src'], MessageType.OK)

  def handle_put(self, msg: dict):
    key, value = msg['key'], msg['value']
    # add the message to the log
    self.log.append(LogEntry(self.term_number, key, value))
    # send append RPCs
    for follower in self.others:
      self.send_append(follower)

  def handle_append_ack(self, msg: dict):
    follower, term, success = msg['src'], msg['term'], msg['success']
    if self.term_number < term:
      self.term_number = term
      if self.assumed_leader == self.id:
        self.assumed_leader = UNKNOWN_ID
    if success:
      confirmed_index = msg['confirmed_index']
      # update confirmed index for follower
      self.follower_confirmed_indices[follower] = confirmed_index
      # update commit index if a majority of followers have confirmed up to at least
      confirmed_at_least = lambda f: self.follower_confirmed_indices[f] >= confirmed_index
      if len(list(filter(confirmed_at_least, self.others))) > len(self.others) // 2:
        self.commit_index = max(self.commit_index, confirmed_index)
    else:
      # todo: handle log resync
      None

  def handle_append(self, msg: dict):
    leader_term, prev_log_index, leader_commit \
      = msg['term'], msg['prev_log_index'], msg['leader_commit']
    entries = list(map(LogEntry.from_dict, msg['entries']))
    success = (
        leader_term >= self.term_number
        and prev_log_index < len(self.log)



        and leader_term == self.log[prev_log_index].term_id
    )
    if success:
      self.update_log(entries, prev_log_index + 1)
    confirmed_index = len(self.log)
    if leader_commit > self.commit_index:
      self.commit_index = min(leader_commit, confirmed_index)
    self.send({
      'term': self.term_number,
      'success': success,
      'confirmed_index': confirmed_index
    }, msg['src'], MessageType.APPEND_ACK)

  def update_log(self, entries: list, offset: int):
      for i in range(len(entries)):
        log_index = offset + i
        if not log_index < len(self.log) or self.log[log_index] != entries[i]:
          self.log = self.log[:log_index] + entries[i:]
          break

  def send_append(self, follower: str):
      prev_log_index = self.follower_confirmed_indices[follower]
      prev_log_term = self.log[prev_log_index].term_id
      entries = list(map(lambda entry: entry.to_dict(), self.log[prev_log_index + 1:]))
      self.send({
        'term': self.term_number,
        'prev_log_index': prev_log_index,
        'prev_log_term': prev_log_term,
        'entries': entries,
        'leader_commit': self.commit_index
      }, follower, MessageType.APPEND)

if __name__ == "__main__":
  parser = argparse.ArgumentParser(description='run a key-value store')
  parser.add_argument('port', type=int, help="Port number to communicate")
  parser.add_argument('id', type=str, help="ID of this replica")
  parser.add_argument('others', metavar='others', type=str, nargs='+', help="IDs of other replicas")
  args = parser.parse_args()
  replica = Replica(args.port, args.id, args.others)
  replica.run()
