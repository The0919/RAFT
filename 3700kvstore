#!/usr/bin/env python3

import argparse, socket, time, json, select, struct, sys, math, os
from enum import Enum

BROADCAST = "FFFF"
UNKNOWN_ID = 'FFFF'

class MessageType(Enum):
  HELLO = 'hello'
  GET = 'get'
  PUT = 'put'
  REDIRECT = 'redirect'
  APPEND = 'append'
  OK = 'ok'

class LogEntry:
  def __init__(self, term_id: int, key: str, value: str):
    self.term_id = term_id
    self.key = key
    self.value = value

class Replica:
  def __init__(self, port, id, others):
    self.assumed_leader = UNKNOWN_ID
    self.term_number = 0
    self.port = port
    self.id = id
    self.others = others

    self.log = []
    self.commit_index = -1
    self.values = {}
    self.follower_commit_indices = dict.fromkeys(others, -1)

    self.socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    self.socket.bind(('localhost', 0))

    print("Replica %s starting up" % self.id, flush=True)
    self.send({}, BROADCAST, MessageType.HELLO)
    print("Sent hello message.", flush=True)

  def send(self, message: dict, to: str, t: MessageType):
    message.update({
      'type': t,
      'src': self.id,
      'dest': to,
      'leader': self.assumed_leader
    })
    self.socket.sendto(json.dumps(message).encode('utf-8'), ('localhost', self.port))

  def run(self):
    while True:
      data, addr = self.socket.recvfrom(65535)
      msg = data.decode('utf-8')

      print("Received message '%s'" % (msg,), flush=True)
      self.handle_msg(json.loads(msg))

  def handle_msg(self, msg: dict):
    msg_type = msg['type']
    if self.id == self.assumed_leader:
      if msg_type == MessageType.GET:
        self.handle_get(msg)
      elif msg_type == MessageType.PUT:
        self.handle_put(msg)
    else:
      if msg_type in [MessageType.GET, MessageType.PUT]:
        self.send({'MID': msg['MID']}, msg['src'], MessageType.REDIRECT)

  def handle_get(self, msg: dict):
    key = msg['key']
    value = self.values[key] if key in self.values else ''
    self.send({'value': value, 'MID': msg['MID']}, msg['src'], MessageType.OK)

  def handle_put(self, msg: dict):
    key, value = msg['key'], msg['value']
    # add the message to the log
    self.log.append(LogEntry(self.term_number, key, value))
    # send append RPCs
    self.replicate_put(len(self.log), key, value)

  def replicate_put(self, log_id: int, key: str, value: str):
    for dest in self.others:
      self.send({'term': self.term_number, ''}, dest, MessageType.APPEND)

if __name__ == "__main__":
  parser = argparse.ArgumentParser(description='run a key-value store')
  parser.add_argument('port', type=int, help="Port number to communicate")
  parser.add_argument('id', type=str, help="ID of this replica")
  parser.add_argument('others', metavar='others', type=str, nargs='+', help="IDs of other replicas")
  args = parser.parse_args()
  replica = Replica(args.port, args.id, args.others)
  replica.run()
